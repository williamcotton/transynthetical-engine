"Do not perform calculations. Do not compute the answer. Use standard JavaScript Math, Date, String, Array, etc to perform calculations. Assume a web browser environment. Always answer with JavaScript compatible code in the %%%PTHUNK%%%. Define new functions in the %%%PTHUNK%%% and use archiver.add() Always write new functions and store them in the Archiver. Always include a description and demonstration of the function in the Archiver. Always answer with this JSON compatible object form: {\"pthunk\":%%%PTHUNK%%%,\"en\":\"%%%EN%%%\"}}}  Write and Archive: write rot13 and pig latin functions{\"pthunk\":\"(async function solution(query, archiver) {\\n    const sentence = \\\"Hello World\\\";\\n    function rot13(str) {\\n        return str\\n            .split(\\\"\\\")\\n            .map((char) => {\\n            const charCode = char.charCodeAt(0);\\n            if (charCode >= 65 && charCode <= 90) {\\n                return String.fromCharCode(((charCode - 65 + 13) % 26) + 65);\\n            }\\n            else if (charCode >= 97 && charCode <= 122) {\\n                return String.fromCharCode(((charCode - 97 + 13) % 26) + 97);\\n            }\\n            else {\\n                return char;\\n            }\\n        })\\n            .join(\\\"\\\");\\n    }\\n    await archiver.add(\\\"rot13\\\", rot13, [{ str: \\\"string\\\" }], `The function rot13 takes a string as an input and applies the ROT13 encryption algorithm to it. This algorithm shifts each letter in the input string by 13 positions in the alphabet while preserving the case and ignoring non-letter characters. For example, the letter \\\"a\\\" would be transformed into \\\"n\\\", \\\"b\\\" into \\\"o\\\", and so on. The function accomplishes this by splitting the input string into an array of individual characters, mapping each character to its ROT13 equivalent using a combination of character codes and modulo arithmetic, and then rejoining the resulting array of transformed characters into a single string.`, `// Example string to encrypt\\nconst message = \\\"Hello, World!\\\";\\n\\n// Encrypt the message using ROT13\\nconst encrypted = rot13(message);\\n\\n// Output the encrypted message\\nconsole.log(encrypted);`);\\n    function pigLatin(word) {\\n        const vowels = [\\\"a\\\", \\\"e\\\", \\\"i\\\", \\\"o\\\", \\\"u\\\"];\\n        if (vowels.includes(word[0])) {\\n            return word + \\\"way\\\";\\n        }\\n        for (let i = 1; i < word.length; i++) {\\n            if (vowels.includes(word[i])) {\\n                return word.slice(i) + word.slice(0, i) + \\\"ay\\\";\\n            }\\n        }\\n        return word + \\\"ay\\\";\\n    }\\n    await archiver.add(\\\"pigLatin\\\", pigLatin, [{ word: \\\"string\\\" }], `The function pigLatin takes a string as an input and applies the Pig Latin algorithm to it. This algorithm takes the first consonant (or consonant cluster) of an English word, moves it to the end of the word and suffixes an \\\"ay\\\". If a word begins with a vowel you just add \\\"way\\\" to the end. For example, the word \\\"computer\\\" becomes \\\"omputercay\\\" and \\\"algorithm\\\" becomes \\\"algorithmway\\\". The function accomplishes this by checking if the first letter of the input string is a vowel, and if not, it iterates through the remaining letters of the string until it finds a vowel. It then returns the substring of the input string starting at the first vowel, followed by the substring of the input string starting at the first letter and ending at the first vowel, followed by the string \\\"ay\\\". If the first letter of the input string is a vowel, it simply returns the input string followed by the string \\\"way\\\".`, `// Example word to convert\\nconst word = \\\"banana\\\";\\n\\n// Convert the word to Pig Latin\\nconst pigLatinWord = pigLatin(word);\\n\\n// Output the Pig Latin version of the word\\nconsole.log(pigLatinWord);`);\\n    return {\\n        answer: [\\\"rot13\\\", \\\"pigLatin\\\"],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\",\"en\":\"\"} Write and Archive: write a function that computes standard deviation{\"pthunk\":\"(async function solution(query, archiver) {\\n    function standardDeviation(numbers) {\\n        const mean = numbers.reduce((acc, curr) => acc + curr, 0) / numbers.length;\\n        const variance = numbers.reduce((acc, curr) => acc + Math.pow(curr - mean, 2), 0) /\\n            numbers.length;\\n        const standardDeviation = Math.sqrt(variance);\\n        return standardDeviation;\\n    }\\n    await archiver.add(\\\"standardDeviation\\\", standardDeviation, [{ number: \\\"array\\\" }], `The function standardDeviation takes an array of numbers as an input and computes the standard deviation of those numbers. The function accomplishes this by first computing the mean of the input numbers, then computing the variance of the input numbers, and finally computing the standard deviation of the input numbers by taking the square root of the variance.`, `// Example array of numbers\\nconst numbers = [1, 2, 3, 4, 5];\\n\\n// Calculate the standard deviation of the numbers\\nconst sd = standardDeviation(numbers);\\n\\n// Output the standard deviation\\nconsole.log(sd);`);\\n    return {\\n        answer: [\\\"standardDeviation\\\"],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\",\"en\":\"\"} Write and Archive: Write a function that predicts the best move in a game of tic-tac-toe{\"pthunk\":\"(async function solution(query, archiver) {\\n    function getEmptySpaces(board) {\\n        const emptySpaces = [];\\n        for (let row = 0; row < board.length; row++) {\\n            for (let col = 0; col < board[row].length; col++) {\\n                if (board[row][col] === null) {\\n                    emptySpaces.push([row, col]);\\n                }\\n            }\\n        }\\n        return emptySpaces;\\n    }\\n    await archiver.add(\\\"getEmptySpaces\\\", getEmptySpaces, [{ board: \\\"array\\\" }], `The function getEmptySpaces takes a tic-tac-toe board as input and returns an array of [row, col] pairs corresponding to the empty spaces on the board.`);\\n    function checkWinner(board) {\\n        for (let i = 0; i < board.length; i++) {\\n            if (board[i][0] !== \\\"_\\\" &&\\n                board[i][0] === board[i][1] &&\\n                board[i][1] === board[i][2]) {\\n                return board[i][0];\\n            }\\n            if (board[0][i] !== \\\"_\\\" &&\\n                board[0][i] === board[1][i] &&\\n                board[1][i] === board[2][i]) {\\n                return board[0][i];\\n            }\\n        }\\n        if (board[0][0] !== \\\"_\\\" &&\\n            board[0][0] === board[1][1] &&\\n            board[1][1] === board[2][2]) {\\n            return board[0][0];\\n        }\\n        if (board[0][2] !== \\\"_\\\" &&\\n            board[0][2] === board[1][1] &&\\n            board[1][1] === board[2][0]) {\\n            return board[0][2];\\n        }\\n        if (getEmptySpaces(board).length === 0) {\\n            return \\\"tie\\\";\\n        }\\n        return null;\\n    }\\n    await archiver.add(\\\"checkWinner\\\", checkWinner, [{ board: \\\"array\\\" }], `The function checkWinner takes a tic-tac-toe board as input and returns the winner of the game (either \\\"X\\\", \\\"O\\\", or \\\"tie\\\") or null if the game is not over.`);\\n    function minimax(board, depth, isMaximizingPlayer) {\\n        const winner = checkWinner(board);\\n        if (winner === \\\"X\\\") {\\n            return 10 - depth;\\n        }\\n        else if (winner === \\\"O\\\") {\\n            return depth - 10;\\n        }\\n        else if (winner === \\\"tie\\\") {\\n            return 0;\\n        }\\n        if (isMaximizingPlayer) {\\n            let bestScore = -Infinity;\\n            const emptySpaces = getEmptySpaces(board);\\n            for (let i = 0; i < emptySpaces.length; i++) {\\n                const [row, col] = emptySpaces[i];\\n                const newBoard = board.map((row) => [...row]);\\n                newBoard[row][col] = \\\"X\\\";\\n                const score = minimax(newBoard, depth + 1, false);\\n                bestScore = Math.max(score, bestScore);\\n            }\\n            return bestScore;\\n        }\\n        else {\\n            let bestScore = Infinity;\\n            const emptySpaces = getEmptySpaces(board);\\n            for (let i = 0; i < emptySpaces.length; i++) {\\n                const [row, col] = emptySpaces[i];\\n                const newBoard = board.map((row) => [...row]);\\n                newBoard[row][col] = \\\"O\\\";\\n                const score = minimax(newBoard, depth + 1, true);\\n                bestScore = Math.min(score, bestScore);\\n            }\\n            return bestScore;\\n        }\\n    }\\n    await archiver.add(\\\"minimax\\\", minimax, [{ board: \\\"array\\\", depth: \\\"number\\\", isMaximizingPlayer: \\\"boolean\\\" }], `The function minimax takes a tic-tac-toe board as input along with the current depth in the game tree and a boolean indicating whether the maximizing player is the current player or not, and returns the score of the board from the perspective of the maximizing player.`);\\n    function predictBestMove(board, player) {\\n        const emptySpaces = getEmptySpaces(board);\\n        const scores = [];\\n        for (let i = 0; i < emptySpaces.length; i++) {\\n            const [row, col] = emptySpaces[i];\\n            const newBoard = board.map((row) => [...row]);\\n            newBoard[row][col] = player;\\n            const score = minimax(newBoard, 0, false);\\n            scores.push(score);\\n        }\\n        const maxScoreIndex = scores.indexOf(Math.max(...scores));\\n        const [row, col] = emptySpaces[maxScoreIndex];\\n        return [row, col];\\n    }\\n    await archiver.add(\\\"predictBestMove\\\", predictBestMove, [{ board: \\\"array\\\", player: \\\"string\\\" }], `The function predictBestMove takes a tic-tac-toe board as input along with the player whose turn it is (either \\\"X\\\" or \\\"O\\\") and returns the best move for that player as an array of [row, col]. The function accomplishes this by using the minimax algorithm to recursively evaluate the game tree, assuming that both players play optimally, and choosing the move that leads to the highest score for the player whose turn it is.`, `// Example Tic-Tac-Toe board\\nconst board = [\\n  [\\\"X\\\", \\\"O\\\", \\\"O\\\"],\\n  [\\\"_\\\", \\\"X\\\", \\\"_\\\"],\\n  [\\\"O\\\", \\\"_\\\", \\\"X\\\"],\\n];\\n\\n// Determine the best move for the player (\\\"X\\\")\\nconst [row, col] = predictBestMove(board, \\\"X\\\");\\n\\n// Output the best move\\nconsole.log(\\\"Best move: \\\" + row + \\\", \\\" + col);`);\\n    return {\\n        answer: [\\\"getEmptySpaces\\\", \\\"checkWinner\\\", \\\"minimax\\\", \\\"predictBestMove\\\"],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\",\"en\":\"\"}"