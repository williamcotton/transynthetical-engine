{
  "exemplars": [
    {
      "augmentedPrompt": "DOM(<div id='context'></div>)\nExistingArchivedFunctions(nullOp() NullOpWebApplication(query:any,archiver:Archiver,document:Document))\nInstructions: define and archive addInputElement\\n  it takes a context element and a value as input\\n  it adds an input element with the value to the context element\\n  it returns the input element\\n\\nuse the (async function): addInputElement to add an input element with the value '512' to the context - ",
      "completion": "{\n  \"pthunk\": \"(async function solution(query, archiver, document) {\\n    async function addInputElement(contextElement, value) {\\n        const inputElement = document.createElement(\\\"input\\\");\\n        inputElement.value = value;\\n        contextElement.appendChild(inputElement);\\n        return inputElement;\\n    }\\n    await archiver.add({\\n        name: \\\"addInputElement\\\",\\n        func: addInputElement,\\n        argTypes: [{ contextElement: \\\"HTMLElement\\\" }, { value: \\\"string\\\" }],\\n        returnType: \\\"HTMLInputElement\\\",\\n        description: `The addInputElement function takes a context element and a value as input and adds an input element with the value to the context element.`,\\n        isApplication: false,\\n    });\\n    const contextElement = document.getElementById(\\\"context\\\");\\n    contextElement.innerHTML = ``;\\n    contextElement.setAttribute(\\\"style\\\", \\\"\\\");\\n    await addInputElement(contextElement, \\\"512\\\");\\n    return {\\n        answer: [\\\"addInputElement\\\"],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\"\n}"
    },
    {
      "augmentedPrompt": "DOM(<div id='context'><input value='512'></div>)\nExistingArchivedFunctions(nullOp(return:null) NullOpWebApplication(query:any,archiver:Archiver,document:Document,return:null) addInputElement(contextElement:HTMLElement,value:string,return:HTMLInputElement))\nInstructions: define and archive (async web-application): TextAlertWebApplication\\n\\nbuild all required elements for the TextAlertWebApplication\\n\\nit should not write a new addInputElement function and it should not expect the addInputElement function to be in the global scope\\nit should use the await archiver.get() the get the existing archived function addInputElement\\nwhen the user presses enter in the input element, it should alert the value of the input element\\n  \\nuse the (async function): TextAlertWebApplication do demonstrate in the existing context - ",
      "completion": "{\n  \"pthunk\": \"(async function solution(query, archiver, document) {\\n    async function TextAlertWebApplication(query, archiver, document) {\\n        const contextElement = document.getElementById(\\\"context\\\");\\n        const addInputElementInstance = await archiver.get(\\\"addInputElement\\\");\\n        const inputElement = await addInputElementInstance(contextElement, \\\"23\\\");\\n        inputElement.addEventListener(\\\"keyup\\\", function (event) {\\n            if (event.key === \\\"Enter\\\") {\\n                alert(inputElement.value);\\n            }\\n        });\\n    }\\n    await archiver.add({\\n        name: \\\"TextAlertWebApplication\\\",\\n        func: TextAlertWebApplication,\\n        argTypes: [\\n            { query: \\\"any\\\" },\\n            { archiver: \\\"Archiver\\\" },\\n            { document: \\\"Document\\\" },\\n        ],\\n        returnType: \\\"undefined\\\",\\n        description: `This application alerts the text in an input element when the enter key is pressed.`,\\n        isApplication: true,\\n    });\\n    await TextAlertWebApplication(query, archiver, document);\\n    return {\\n        answer: [\\\"TextAlertWebApplication\\\"],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\"\n}"
    },
    {
      "augmentedPrompt": "DOM(<div id='context'><input value='23'></div>)\nExistingArchivedFunctions(nullOp(return:null) NullOpWebApplication(query:any,archiver:Archiver,document:Document,return:null) addInputElement(contextElement:HTMLElement,value:string,return:HTMLInputElement) TextAlertWebApplication(query:any,archiver:Archiver,document:Document,return:undefined))\nInstructions: reset and load the text alert app - ",
      "completion": "{\n  \"pthunk\": \"(async function solution(query, archiver, document) {\\n    const contextElement = document.getElementById(\\\"context\\\");\\n    contextElement.innerHTML = ``;\\n    contextElement.setAttribute(\\\"style\\\", \\\"\\\");\\n    const TextAlertWebApplicationInstance = await archiver.get(\\\"TextAlertWebApplication\\\");\\n    await TextAlertWebApplicationInstance(query, archiver, document);\\n    return {\\n        answer: [],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\"\n}"
    },
    {
      "augmentedPrompt": "DOM(<div id='context'><input value='23'></div>)\nExistingArchivedFunctions()\nInstructions: clear the context and add an h1 that says 'Context' - ",
      "completion": "{\n  \"pthunk\": \"(async function solution(query, archiver, document) {\\n    const contextElement = document.getElementById(\\\"context\\\");\\n    contextElement.innerHTML = ``;\\n    contextElement.setAttribute(\\\"style\\\", \\\"\\\");\\n    const titleElement = document.createElement(\\\"h1\\\");\\n    titleElement.innerText = \\\"Context\\\";\\n    contextElement.appendChild(titleElement);\\n    return {\\n        answer: [],\\n        solutions: [],\\n        computed: true,\\n        query: false,\\n    };\\n}\\n)\"\n}"
    }
  ],
  "preamble": "DOM(<div id=\"context\"></div>) ExistingArchivedFunctions() Instructions: natural language instructions -  {\"pthunk\":%%%PTHUNK%%%}  Use the natural language instructions to write JavaScript code in the %%%PTHUNK%%% Use standard JavaScript Math, Number, Date, RegExp, String, Array, Object, Map, Set, JSON, Promise, Intl. Assume a web browser environment and document. Do not answer in Markdown. Always answer with JavaScript compatible code in the %%%PTHUNK%%%. Functions in ExistingArchivedFunctions() do exist and should be used with await archiver.get() in scope of the %%%PTHUNK%%% If not in ExistingArchivedFunctions() define new async functions and include a description in the %%%PTHUNK%%% and use await archiver.add() Don't use await archiver.get() to the get the async functions defined and already archived in scope of the %%%PTHUNK%%% Web application async functions should be defined with names like ExampleWebApplication(query, archiver, document) if they do not exist in in the ExistingArchivedFunctions() Web application async functions should be written in the %%%PTHUNK%%% Web application async functions should be added to the archive and use await archiver.add() Don't call await archiver.get() to get a async function that was defined and added to the await archiver in the same %%%PTHUNK%%% Assume all archived and defined functions are async functions in scope of the %%%PTHUNK%%% Always update the Web Browser document (DOM) based on the DOM(HTML context) when given an instruction. Always answer with this JSON compatible object form: {\"pthunk\":%%%PTHUNK%%%}",
  "augmentedPrompt": ""
}